# особенности curve25519
Т.к. из-за особенностей этой реализации кривой для расшифровки необходимо знать публичный шифровщика, это несколько ставит под вопрос, при решении в лоб, возможность лёгкой deniability. Однако, использование двуслойного подхода может обойти это ограничение. Так, первый слой получается из случайно пары, причём публичный ключ даётся явно, во втором же слое даётся уже тот публичный, который шифрующий хочет чтобы ассоциировался с ним у адресата. Во втором слое также находятся всё, что связанно с сообщением - aes-зашифрованные ipfs файлов, зашифрованный публичным aes ключ, опциально криптографическая подпись всего, опциально ipns. 


# check
* смотрит в список ipns (для mvp - один слой, а так в конфиге указывается количество слоёв)
* начинает качать json ноды (с таймаутом? - возможно использовать вручную http api ipfs и requests т.к. там есть таймаут)
* добавляет сообщения в накопитель, при наличии
* проверяет есть ли сообщения, адресованные пользователю (возможно проходит по всем использованным публичникам или по всем, в зависимости от настроек)
* те сообщения, что адресованы не пользователю с некой вероятностью ставит в свой пулл сообщений на ноде (возможно как-то учитывать ttl), и записывает в новый стейт json-бд сообщений в общую бд json ноды.
* подсчитывает сколько сообщений от некого адреса (или ника, если есть в ростере) и показывает пользователю, он выбирает что скачивать.
* скачивание происходит в папку с адресом/ником и в подпапку с id сообщения.
* (возможно сделать настройку, при которой команда постоянно проверяет ноды с некой периодичностью и скачивает сразу все новые сообщения)

# send <папка> <адрес>

* смотри в папку, составляет список файлов, грузит в память, кодирует рандомным AES, получает ipfs-хэш файла (возможно использовать внешние гейтвеи для внешнего хэширования - т.е. скачать свои файлы из нескольких)
* сбор json сообщения, добавление его в пулл сообщений в бд.
* обновление json ноды в ipns (т.к. сначала необходимо у всего json ноды всё равно получить ipfs хэш, то тут тоже можно провернуть хэширование через внешние гейты).

# roster команды
* как дополнение, на первых этапах можно держать внешний json, дополняющийся вручную.



# разное
* возможно показывать пользователю потенциальный размер файлов в сообщении (или всего сообщения), чтобы он видел что качает. ``` ipfs object stat ```

